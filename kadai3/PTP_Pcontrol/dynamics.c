/***************************************************************************************/
/* Dynamic Simulation of a Planar 2DoF Robotic Arm, Copyright Atsushi Kakogawa         */
/* Created April 23, 2020, Department of Robotics, Ritsumeikan University, Japan       */
/***************************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <GL/glut.h>
#include <math.h>
#include <string.h>
#include "function.h"

void controller() {

/**************************************************************************************************/
/***** Target Trajectory of the Arm End ***********************************************************/
/**************************************************************************************************/
	if (t <= T) {
	/*	xd = -2 * (xend - xini) * (t / T) * (t / T) * (t / T) + 3 * (xend - xini) * (t / T) * (t / T) + xini;
		yd = -2 * (yend - yini) * (t / T) * (t / T) * (t / T) + 3 * (yend - yini) * (t / T) * (t / T) + yini;*/
		/*theta_rev[1] = (atan2(yd, xd) - acos(((len[1] * len[1]) - (len[2] * len[2]) + (xd * xd) + (yd * yd)) / (2 * len[1] * sqrt((xd * xd) + (yd * yd)))));
		theta_rev[2] = pi - acos(((len[1] * len[1]) + (len[2] * len[2]) - ((xd * xd) + (yd * yd))) / (2 * len[1] * len[2]));
		thed[1] = -2 * (theend[1] - theini[1]) * (t / T) * (t / T) * (t / T) + 3 * (theend[1] - theini[1]) * (t / T) * (t / T) + theini[1];
		thed[2] = -2 * (theend[2] - theini[2]) * (t / T) * (t / T) * (t / T) + 3 * (theend[2] - theini[2]) * (t / T) * (t / T) + theini[2];*/

		theta_e[1] += (theta_rev_ptp[1] - the[1]) * dt;
		theta_e[2] += (theta_rev_ptp[2] - the[2]) * dt;
	}
/**************************************************************************************************/
/***** Jacobian Matrix ****************************************************************************/
/**************************************************************************************************/
	
	J[1] = - len[1] * sin(the[1]) - len[2] * sin(the[1] + the[2]);
	J[2] = - len[2] * sin(the[1] + the[2]);
	J[3] = len[1] * cos(the[1]) + len[2] * cos(the[1] + the[2]);
	J[4] = len[2] * cos(the[1] + the[2]);

/**************************************************************************************************/
/***** Controller: Input to the robot (joint torque) **********************************************/
/**************************************************************************************************/

	//U[1] = kpx * (xd - x[2]);
	//U[2] = kpy * (yd - y[2]);
	//tau[1] = -kd[1] * dthe[1];
	//tau[2] = -kd[2] * dthe[2];
	
	//tau[1] = J[1] * U[1] + J[3] * U[2] - kd[1] * dthe[1];
	//tau[2] = J[2] * U[1] + J[4] * U[2] - kd[2] * dthe[2];

	//theta_rev[1] = (atan2(yd, xd) - acos(((len[1] * len[1]) - (len[2] * len[2]) + (xd * xd) + (yd * yd)) / (2 * len[1] * sqrt((xd * xd) + (yd * yd)))));
	//theta_rev[2] = pi - acos(((len[1] * len[1]) + (len[2] * len[2]) - ((xd * xd) + (yd * yd))) / (2 * len[1] * len[2]));
	
	//tau[1] = kpx * (theta_rev[1] - the[1]) - kd[1] * dthe[1];
	//tau[2] = kpy * (theta_rev[2] - the[2]) - kd[2] * dthe[2];


	////PD§Œä
	//tau[1] = kpx * (thed[1] - the[1]) - kd[1] * dthe[1];
	//tau[2] = kpy * (thed[2] - the[2]) - kd[2] * dthe[2];

	////PID§Œä
	//tau[1] = kpx * (thed[1] - the[1]) - kd[1] * dthe[1] + kix * theta_e[1];
	//tau[2] = kpy * (thed[2] - the[2]) - kd[2] * dthe[2] + kiy * theta_e[2];
	
    //‹t‰^“®Šw‚É‚æ‚éŽèæˆÊ’uPID§Œä
	tau[1] = kpx * (theta_rev_ptp[1] - the[1]) - kd[1] * dthe[1] + kix * theta_e[1];
	tau[2] = kpy * (theta_rev_ptp[2] - the[2]) - kd[2] * dthe[2] + kiy * theta_e[2];

}

void dynamics(){

/**************************************************************************************************/
/***** Inertia matrix *****************************************************************************/
/**************************************************************************************************/

	// 4*4 matrix
	M[1] = I[1] + I[2] + m[1]*lenG[1]*lenG[1] + m[2]*len[1]*len[1] + m[2]*lenG[2]*lenG[2] + 2*m[2]*len[1]*lenG[2]*cos(the[2]);
	M[2] = I[2] + m[2] * lenG[2] * lenG[2] + m[2] * len[1] * lenG[2] * cos(the[2]);
	M[3] = M[2];
	M[4] = I[2] + m[2] * lenG[2] * lenG[2];

/**************************************************************************************************/
/***** Calculation of the inverse matrix **********************************************************/
/**************************************************************************************************/

	inv_M[1] = 1 / (M[1] * M[4] - M[2] * M[3])*M[4];
	inv_M[2] = -1 / (M[1] * M[4] - M[2] * M[3])*M[2];
	inv_M[3] = -1 / (M[1] * M[4] - M[2] * M[3])*M[3];
	inv_M[4] = 1 / (M[1] * M[4] - M[2] * M[3])*M[1];

/**************************************************************************************************/
/***** Vector of centrifugal and coriolis forces **************************************************/
/**************************************************************************************************/

	C[1] = -m[2] * len[1] * lenG[2] * (2 * dthe[1] * dthe[2] + dthe[2] * dthe[2]) * sin(the[2]);
	C[2] = m[2] * len[1] * lenG[2] * dthe[1] * dthe[1] * sin(the[2]);

/**************************************************************************************************/
/***** Vector of gravitational force **************************************************************/
/**************************************************************************************************/

	G[1] = m[1] * g *lenG[1] * cos(the[1]) + m[2] * g *len[1] * cos(the[1]) + m[2] * g *lenG[2] * cos(the[1] + the[2]);
	G[2] = m[2] * g *lenG[2] * cos(the[1] + the[2]);

/**************************************************************************************************/
/***** Forward Dynamics ***************************************************************************/
/**************************************************************************************************/

	A = tau[1] - C[1] - G[1];
	B = tau[2] - C[2] - G[2];

	ddthe[1] = inv_M[1] * A + inv_M[2] * B;
	ddthe[2] = inv_M[3] * A + inv_M[4] * B;

/**************************************************************************************************/
/***** Newton Method (Integral of acceralation) ***************************************************/
/**************************************************************************************************/
	
	dthe[1] += ddthe[1] * dt;
	dthe[2] += ddthe[2] * dt;
	the[1] += dthe[1] * dt;
	the[2] += dthe[2] * dt;

/**************************************************************************************************/
/***** Forward Kinematics *********************************************************************************/
/**************************************************************************************************/

	x[1] = len[1] * cos(the[1]);
	y[1] = len[1] * sin(the[1]);
	x[2] = len[1] * cos(the[1]) + len[2] * cos(the[1] + the[2]);
	y[2] = len[1] * sin(the[1]) + len[2] * sin(the[1] + the[2]);

	/* Optional */
	xG[1] = lenG[1] * cos(the[1]);
	yG[1] = lenG[1] * sin(the[1]);
	xG[2] = len[1] * cos(the[1]) + lenG[2] * cos(the[1] + the[2]);
	yG[2] = len[1] * sin(the[1]) + lenG[2] * sin(the[1] + the[2]);

}